---
title: "Fertility rates in South America"
format:
  html: default
  pdf:
    documentclass: article
editor: visual
---

# Data

```{r}
latam_iso3 <- c("ARG", "BOL", "BRA", "CHL", "COL", "ECU", "PER", "URY", "VEN")
```

```{r}
library(readxl)

fertility_rates_file <- "Data/WPP2024_FERT_F01_FERTILITY_RATES_BY_SINGLE_AGE_OF_MOTHER.xlsx"

temp <- read_excel(fertility_rates_file,
                   skip = 16,
                   n_max = 1)
total_cols <- ncol(temp)

fertility_rates <- read_excel(fertility_rates_file,
                              skip=16,
                              col_types = c("numeric", "text", "text", "text",
                                            "text",  # Location code
                                            "text", "text",  # ISO3 and ISO2
                                            "numeric", "text", "numeric",
                                            "numeric",  # Year
                                            rep("numeric", total_cols - 11)))
```

```{r}
library(dplyr)

process_bd <- function(bd, start_year, end_year) {
  bd <- bd %>%
    filter(`ISO3 Alpha-code` %in% latam_iso3) %>%
    rename(Country = `Region, subregion, country or area *`)

  age_group_regex <- "^\\d+$"
  bd <- bd %>%
    select(
      all_of(c("Country", "ISO3 Alpha-code", "Year")),
      matches(age_group_regex)
    )

  start_year = 2010
  end_year = 2023

  bd <- bd %>%
    filter(start_year <= Year & Year <= end_year)
}
```

```{r}
fertility_rates <- process_bd(fertility_rates)
```

```{r}
library(tidyverse)

fertility_long <- fertility_rates %>%
  pivot_longer(
    cols = `15`:`49`,        # columns to pivot (note the backticks since they're numeric colnames)
    names_to = "MothersAge",        # new column for age
    values_to = "FertilityRate"  # new column for fertility rate values
  )
```

```{r}
library(readxl)

total_births_file <- "Data/WPP2024_FERT_F03_BIRTHS_BY_SINGLE_AGE_OF_MOTHER.xlsx"

temp <- read_excel(total_births_file,
                   skip = 16,
                   n_max = 1)
total_cols <- ncol(temp)

total_births <- read_excel(total_births_file,
                          skip=16,
                          col_types = c("numeric", "text", "text", "text",
                                        "text",  # Location code
                                        "text", "text",  # ISO3 and ISO2
                                        "numeric", "text", "numeric",
                                        "numeric",  # Year
                                        rep("numeric", total_cols - 11)))
```

```{r}
total_births <- process_bd(total_births)

births_long <- total_births %>%
  pivot_longer(
    cols = `15`:`49`,
    names_to = "MothersAge",
    values_to = "Births"
  )
```

```{r}
births_data <- inner_join(
  births_long,
  fertility_long,
  by = c("Country", "ISO3 Alpha-code", "Year", "MothersAge")
)

births_data <- births_data %>%
  mutate(Births = Births * 1000) %>%
  mutate(TotalWomen = (Births * 1000) / FertilityRate)
```

```{r}
library(tidyverse)

births_data_grouped <- births_data %>%
  mutate(AgeGroup = if_else(as.numeric(MothersAge) <= 18, "le18", "g18")) %>%
  group_by(Country, `ISO3 Alpha-code`, Year, AgeGroup) %>%
  summarise(
    Births = sum(Births, na.rm = TRUE),
    TotalWomen  = sum(TotalWomen, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  pivot_wider(
    names_from = AgeGroup,
    values_from = c(Births, TotalWomen)
  )

births_data_grouped <- births_data_grouped %>%
  mutate(
    `FertilityRate_le18`  = (`Births_le18` / `TotalWomen_le18`) * 1000,
    `FertilityRate_g18`  = (`Births_g18` / `TotalWomen_g18`) * 1000
  )
```

```{r}
library(ggplot2)
library(tidyverse)
library(glue)

# Crear una columna abreviada para la leyenda
births_data_grouped <- births_data_grouped %>%
  mutate(Country_abbr = substr(Country, 1, 3))

graph_age <- function(age) {
  ggplot(births_data_grouped, aes(x = Year, y = .data[[age]], color = Country_abbr, group = Country)) +
    geom_line(size = 0.8) +
    geom_point() +
    labs(
      title = glue("Fertility rates in {age}"),
      subtitle = "(births per 1,000 women)",
      x = "Year",
      y = "Birth rates",
      color = "Country"
    ) +
    theme_minimal() +
    theme(
      legend.position = "right",
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold")
    )
}

graph_age("FertilityRate_le18")
graph_age("FertilityRate_g18")
```

```{r}
library(sf)
library(ggplot2)
library(dplyr)
library(rnaturalearth)
library(tidyr)
library(RColorBrewer)

south_america <- ne_countries(scale = "medium", continent = "South America", returnclass = "sf")

draw_heat_map_year <- function(years, age) {
  data <- fertility_rates %>%
    select(Country, Year, `ISO3 Alpha-code`, .data[[age]]) %>%
    filter(Year %in% years)

  map_data <- south_america %>%
    left_join(data, by = c("iso_a3" = "ISO3 Alpha-code")) %>%
    drop_na(Year)

  ggplot(data = map_data) +
    geom_sf(aes(fill = .data[[age]]), color = "black") +
    
    # Usar paleta "Blues" con 7 tonos
    scale_fill_stepsn(
      colours = brewer.pal(7, "Blues"),
      breaks = c(0, 25, 50, 75, 100, 125, 150),
      limits = c(0, 150),
      name = "(births per 1,000 women)",
      na.value = "gray90"
    ) +
    
    labs(
      title = glue("Age-specific fertility rates by {age} age"),
      subtitle = ""
    ) +
    
    facet_wrap(~Year, ncol = 3) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      plot.subtitle = element_text(hjust = 0.5, size = 12),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      strip.text = element_text(face = "bold", size = 10),
      legend.position = "right",
      legend.text = element_text(size = 8),
      panel.grid = element_blank(),
      panel.spacing = unit(0.5, "lines")
    )
}

draw_heat_map_year(c(2010, 2015, 2020, 2021, 2022, 2023), "15")
draw_heat_map_year(c(2010, 2015, 2020, 2021, 2022, 2023), "17")
draw_heat_map_year(c(2010, 2015, 2020, 2021, 2022, 2023), "20")
```

```{r}
library(readr)

cima_learning <- read_csv("Data/cima_learning.csv")

pisa_scores <- cima_learning %>%
  filter(Country %in% latam_iso3, CIMA_Indicator == "Puntaje_Prom",
         Class == "Total", Source == "PISA")
```

```{r}
graph_score <- function(subject) {
  pisa_subject_scores <- pisa_scores %>%
    filter(Subject == subject)
  ggplot(pisa_subject_scores, aes(x = Year, y = Value, color = Country, group = Country)) +
    geom_line(size = 0.8) +  # Adjust the line thickness
    geom_point() +
    labs(
      title = glue("PISA scores in subject {subject}"),
      x = "Year",
      y = "Score"
    ) +
    theme_minimal() +
    theme(
      legend.position = "right",
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    )
}

graph_score("Ciencias")
graph_score("Matematicas")
graph_score("Lectura")
```

```{r}
# Obtener el mapa de Sudam√©rica
south_america <- ne_countries(scale = "medium", continent = "South America", returnclass = "sf")

# Funci√≥n para graficar mapas por subject
draw_heat_map_subject <- function(subject) {
  message(glue("Usando subject: {subject}"))  # Verifica qu√© subject se est√° usando

  data <- pisa_scores %>%
    filter(tolower(Subject) == tolower(subject))  # Comparaci√≥n segura

  map_data <- south_america %>%
    left_join(data, by = c("iso_a3" = "Country")) %>%
    drop_na(Year)

  # Normalizar subject a min√∫sculas
  subject_lower <- tolower(subject)

  # Establecer rango de colores y paleta seg√∫n el subject
  if (subject_lower == "ciencias") {
    color_limits <- c(350, 470)
    palette_name <- "Blues"
  } else if (subject_lower == "matem√°ticas") {
    color_limits <- c(320, 480)
    palette_name <- "Reds"
  } else if (subject_lower == "lectura") {
    color_limits <- c(340, 510)
    palette_name <- "Greens"
  } else {
    color_limits <- c(300, 500)
    palette_name <- "Greys"
  }

  # Crear gr√°fico
  ggplot(data = map_data) +
    geom_sf(aes(fill = Value), color = "black") +
    scale_fill_stepsn(
      colours = brewer.pal(7, palette_name),
      breaks = seq(color_limits[1], color_limits[2], length.out = 7),
      labels = function(x) round(x),
      limits = color_limits,
      na.value = "gray90",
      name = "PISA\ntotal score"
    ) +
    labs(
      title = glue("PISA scores in subject {subject}"),
      subtitle = ""
    ) +
    facet_wrap(~Year, ncol = 3) +  # 3 columnas ‚Üí 2 filas si hay 6 a√±os
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      plot.subtitle = element_text(hjust = 0.5, size = 12),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      strip.text = element_text(face = "bold", size = 10),
      legend.position = "right",
      legend.direction = "vertical",
      legend.text = element_text(size = 8),
      legend.title = element_text(face = "bold", size = 9),
      legend.key.height = unit(0.5, "cm"),
      panel.grid = element_blank(),
      panel.spacing = unit(0.5, "lines")
    )
}

draw_heat_map_subject("Ciencias")
draw_heat_map_subject("Matematicas")
draw_heat_map_subject("Lectura")
```

```{r}
view(fertility_rates)
view(fertility_long)

# Paso 1: Sumar la tasa de fertilidad total por pa√≠s y a√±o
fertilidad_total <- fertility_long %>%
  group_by(Country, Year) %>%
  summarise(TotalFertility = sum(FertilityRate), .groups = "drop")

# Paso 2: Pivotear ‚Äî ahora los a√±os ser√°n columnas
tabla_resumen <- fertilidad_total %>%
  pivot_wider(names_from = Year, values_from = TotalFertility)

# Paso 3: Ver tabla
View(tabla_resumen)
```

```{r}
# Graficar
fertilidad_total_mod <- fertilidad_total %>%
  mutate(Pais_Abrev = substr(Country, 1, 3))

# Usar la abreviatura en el mapeo de color
ggplot(fertilidad_total_mod, aes(x = Year, y = TotalFertility, color = Pais_Abrev)) +
  geom_line(size = 1) +
  geom_point(size = 1.5) +
  labs(
    title = "Tasa Total de Fertilidad por Pa√≠s (2010‚Äì2023)",
    x = "A√±o",
    y = "Tasa Total de Fertilidad",
    color = "Pa√≠s"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

```{r}
elbow_and_silhouette <- function(data) {
  library(factoextra)
  library(gridExtra)

  n_obs <- nrow(data)
  k_max <- min(10, n_obs - 1)

  # Elbow method (WSS)
  elbow_plot <- fviz_nbclust(data, kmeans, method = "wss", k.max = k_max) +
    labs(title = "Elbow Method (WSS)")

  # Silhouette method
  silhouette_plot <- fviz_nbclust(data, kmeans, method = "silhouette", k.max = k_max) +
    labs(title = "Silhouette Method")

  # Combine plots side by side
  grid.arrange(elbow_plot, silhouette_plot, ncol = 2)
}
```

```{r}
clusterize <- function(data, k) {
  library(factoextra)
  library(dendextend)

  # Calculate the distance matrix (using Euclidean distance)
  distance_matrix <- dist(data, method = "euclidean")

  # Perform hierarchical clustering (using complete linkage method)
  hclust_result <- hclust(distance_matrix, method = "complete")

  # Plot the dendrogram
  dend <- fviz_dend(hclust_result, k = k,  # Number of desired clusters
            cex = 0.5,             # Text size
            k_colors = c("red", "blue", "green"),  # Cluster colors
            rect = TRUE,           # Draw rectangles around clusters
            rect_border = "gray",
            rect_fill = TRUE,
            main = "Dendrogram of Hierarchical Clustering ...")

  # Assign observations to clusters (k = desired number of clusters)
  cluster_assignments <- cutree(hclust_result, k = k)  # Adjust "k" for the desired number of clusters

  # Visualize clusters in PCA space
  clusters <- fviz_cluster(
    list(data = data, cluster = cluster_assignments),
    geom = "point",
    ellipse.type = "convex",  # Draw convex hulls around clusters
    ggtheme = theme_minimal(),
    main = "Hierarchical Clustering Visualization with PCA"
  )

  return(list(
    dendrogram = dend,
    cluster_plot = clusters,
    assignments = cluster_assignments
  ))
}
```

```{r}
start_year <- 2010
end_year <- 2014

year_cols <- as.character(start_year:end_year)
data_range_1 <- tabla_resumen[, year_cols]
data_scaled_1 <- scale(data_range_1)
```

```{r}
elbow_and_silhouette(data_scaled_1)
```

```{r}
rownames(data_range_1) <- substr(tabla_resumen$Country, 1, 3)
data_scaled_1 <- scale(data_range_1)
clusterize(data_scaled_1, 3)
```

```{r}
start_year <- 2015
end_year <- 2019

year_cols <- as.character(start_year:end_year)
data_range_2 <- tabla_resumen[, year_cols]

rownames(data_range_2) <- substr(tabla_resumen$Country, 1, 3)

data_scaled_2 <- scale(data_range_2)
```

```{r}
elbow_and_silhouette(data_scaled_2)
clusterize(data_scaled_2, 3)
```

```{r}
start_year <- 2020
end_year <- 2023

year_cols <- as.character(start_year:end_year)
data_range_3 <- tabla_resumen[, year_cols]

rownames(data_range_3) <- substr(tabla_resumen$Country, 1, 3)

data_scaled_3 <- scale(data_range_3)
```

```{r}
elbow_and_silhouette(data_scaled_3)
clusterize(data_scaled_3, 3)
```

```{r}
# Cargar librer√≠as necesarias
library(dplyr)

# Leer el archivo original (aseg√∫rate de tener el archivo en el directorio de trabajo)
data_original <- read.csv("tabla_resumen_fertilidad_transpuesta.csv", check.names = FALSE)

# Renombrar la primera columna como "Country"
colnames(data_original)[1] <- "Country"

# Seleccionar columnas de 2010 a 2014
data_years <- data_original[, c("Country", "2010", "2011", "2012", "2013", "2014")]

# Escalar solo las columnas num√©ricas (excluyendo "Country")
data_scaled_1 <- scale(data_years[, -1])  # Excluye la columna "Country"

# Clustering jer√°rquico
hclust_result <- hclust(dist(data_scaled_1))
clusters_hierarchical <- cutree(hclust_result, k = 3)

# Combinar Country, datos originales y clusters
data_combined_2010_2014 <- data_years %>%
  mutate(Cluster = as.factor(clusters_hierarchical))

# Intercambiar etiquetas de cluster 1 y 2
data_combined_2010_2014 <- data_combined_2010_2014 %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

# Mostrar los primeros resultados
head(data_combined_2010_2014)

```

```{r}
# Cargar librer√≠as necesarias
library(dplyr)
library(tidyr)
library(ggplot2)

# Leer el archivo original
data_original <- read.csv("tabla_resumen_fertilidad_transpuesta.csv", check.names = FALSE)

# Renombrar la primera columna como "Country"
colnames(data_original)[1] <- "Country"

# Seleccionar columnas de 2010 a 2014
data_years <- data_original[, c("Country", "2010", "2011", "2012", "2013", "2014")]

# Escalar solo las columnas num√©ricas
data_scaled_1 <- scale(data_years[, -1])

# Clustering jer√°rquico
hclust_result <- hclust(dist(data_scaled_1))
clusters_hierarchical <- cutree(hclust_result, k = 3)

# Combinar Country, datos originales y clusters
data_combined_2010_2014 <- data_years %>%
  mutate(Cluster = as.factor(clusters_hierarchical))

# Intercambiar etiquetas de cluster 1 y 2
data_combined_2010_2014 <- data_combined_2010_2014 %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

# Convertir a formato largo
data_long <- data_combined_2010_2014 %>%
  pivot_longer(
    cols = starts_with("20"),
    names_to = "Year",
    values_to = "Emissions"
  ) %>%
  mutate(
    Year = as.numeric(Year),
    Country_abbr = substr(Country, 1, 3)
  )

# Crear el gr√°fico con facetas en vertical sin etiquetas
ggplot(data_long, aes(x = Year, y = Emissions, color = Country_abbr, group = Country)) +
  geom_line(size = 0.8) +
  geom_point(size = 2) +
  facet_wrap(~Cluster, ncol = 1, strip.position = "left", scales = "free_y") +  # Vertical, escalas libres
  scale_x_continuous(breaks = 2010:2014) +
  theme_minimal() +
  labs(
    title = "Tasa de Fertilidad por Pa√≠s y Cluster (2010‚Äì2014)",
    subtitle = "Agrupado seg√∫n clustering jer√°rquico",
    x = "A√±o",
    y = "Tasa estandarizada",
    color = "Pa√≠s"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text.x = element_text(size = 8),
    legend.position = "right",
    panel.spacing = unit(1, "lines"),
    strip.text = element_blank(),  # Quitar las etiquetas de los clusters
    aspect.ratio = 0.3              # Hace los paneles m√°s delgados (ajustable)
  )


```

```{r}
# Cargar librer√≠as necesarias
library(dplyr)

# Leer el archivo original (aseg√∫rate de tener el archivo en el directorio de trabajo)
data_original <- read.csv("tabla_resumen_fertilidad_transpuesta.csv", check.names = FALSE)

# Renombrar la primera columna como "Country"
colnames(data_original)[1] <- "Country"

# Seleccionar columnas de 2015 a 2019
data_years <- data_original[, c("Country", "2015", "2016", "2017", "2018", "2019")]

# Escalar solo las columnas num√©ricas (excluyendo "Country")
data_scaled_2 <- scale(data_years[, -1])  # Excluye la columna "Country"

# Clustering jer√°rquico
hclust_result <- hclust(dist(data_scaled_2))
clusters_hierarchical <- cutree(hclust_result, k = 3)

# Combinar Country, datos originales y clusters
data_combined_2015_2019 <- data_years %>%
  mutate(Cluster = as.factor(clusters_hierarchical))

# Intercambiar etiquetas de cluster 1 y 2
data_combined_2015_2019 <- data_combined_2015_2019 %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

# Mostrar los primeros resultados
head(data_combined_2015_2019)
```

```{r}
# Cargar librer√≠as necesarias
library(dplyr)
library(tidyr)
library(ggplot2)

# Leer el archivo original
data_original <- read.csv("tabla_resumen_fertilidad_transpuesta.csv", check.names = FALSE)

# Renombrar la primera columna como "Country"
colnames(data_original)[1] <- "Country"

# Seleccionar columnas de 2015 a 2019
data_years <- data_original[, c("Country", "2015", "2016", "2017", "2018", "2019")]

# Escalar solo las columnas num√©ricas
data_scaled_2 <- scale(data_years[, -1])

# Clustering jer√°rquico
hclust_result <- hclust(dist(data_scaled_2))
clusters_hierarchical <- cutree(hclust_result, k = 3)

# Combinar Country, datos originales y clusters
data_combined_2015_2019 <- data_years %>%
  mutate(Cluster = as.factor(clusters_hierarchical))

# Intercambiar etiquetas de cluster 1 y 2
data_combined_2015_2019 <- data_combined_2015_2019 %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

# Convertir a formato largo
data_long_2 <- data_combined_2015_2019 %>%
  pivot_longer(
    cols = starts_with("20"),
    names_to = "Year",
    values_to = "Tasa_de_fertilidad"
  ) %>%
  mutate(
    Year = as.numeric(Year),
    Country_abbr = substr(Country, 1, 3)
  )

# Crear gr√°fico final sin etiquetas de cluster y con gr√°ficos delgados
ggplot(data_long_2, aes(x = Year, y = Tasa_de_fertilidad, color = Country_abbr, group = Country)) +
  geom_line(size = 0.8) +
  geom_point(size = 2) +
  facet_wrap(~Cluster, ncol = 1, strip.position = "left", scales = "free_y") +
  scale_x_continuous(breaks = 2015:2019) +
  theme_minimal() +
  labs(
    title = "Tasa de Fertilidad por Pa√≠s y Cluster (2015‚Äì2019)",
    subtitle = "Agrupado seg√∫n clustering jer√°rquico",
    x = "A√±o",
    y = "Tasa estandarizada",
    color = "Pa√≠s"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text.x = element_text(size = 8),
    legend.text = element_text(size = 8),
    legend.title = element_text(face = "bold", size = 9),
    legend.position = "right",
    panel.spacing = unit(1, "lines"),
    strip.text = element_blank(),  # Quitar los n√∫meros de los clusters
    aspect.ratio = 0.3              # Hacer los gr√°ficos m√°s delgados
  )

```

```{r}
# Cargar librer√≠as necesarias
library(dplyr)

# Leer el archivo original (aseg√∫rate de tener el archivo en el directorio de trabajo)
data_original <- read.csv("tabla_resumen_fertilidad_transpuesta.csv", check.names = FALSE)

# Renombrar la primera columna como "Country"
colnames(data_original)[1] <- "Country"

# Seleccionar columnas de 2020 a 2023
data_years <- data_original[, c("Country", "2020", "2021", "2022", "2023")]

# Escalar solo las columnas num√©ricas (excluyendo "Country")
data_scaled_3 <- scale(data_years[, -1])  # Excluye la columna "Country"

# Clustering jer√°rquico
hclust_result <- hclust(dist(data_scaled_3))
clusters_hierarchical <- cutree(hclust_result, k = 3)

# Combinar Country, datos originales y clusters
data_combined_2020_2023 <- data_years %>%
  mutate(Cluster = as.factor(clusters_hierarchical))

# Intercambiar etiquetas de cluster 1 y 2
data_combined_2020_2023 <- data_combined_2020_2023 %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

# Mostrar los primeros resultados
head(data_combined_2020_2023)
```

```{r}
# Cargar librer√≠as necesarias
library(dplyr)
library(tidyr)
library(ggplot2)

# Leer el archivo original
data_original <- read.csv("tabla_resumen_fertilidad_transpuesta.csv", check.names = FALSE)

# Renombrar la primera columna como "Country"
colnames(data_original)[1] <- "Country"

# Seleccionar columnas de 2020 a 2023
data_years <- data_original[, c("Country", "2020", "2021", "2022", "2023")]

# Escalar solo las columnas num√©ricas
data_scaled_3 <- scale(data_years[, -1])

# Clustering jer√°rquico
hclust_result <- hclust(dist(data_scaled_3))
clusters_hierarchical <- cutree(hclust_result, k = 3)

# Combinar Country, datos originales y clusters
data_combined_2020_2023 <- data_years %>%
  mutate(Cluster = as.factor(clusters_hierarchical))

# Intercambiar etiquetas de cluster 1 y 2
data_combined_2020_2023 <- data_combined_2020_2023 %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

# Convertir los datos a formato largo
data_long_3 <- data_combined_2020_2023 %>%
  pivot_longer(
    cols = starts_with("20"),
    names_to = "Year",
    values_to = "Tasa_de_fertilidad"
  ) %>%
  mutate(
    Year = as.numeric(Year),
    Country_abbr = substr(Country, 1, 3)
  )

# Crear el gr√°fico final sin etiquetas de cluster y con gr√°ficos delgados
ggplot(data_long_3, aes(x = Year, y = Tasa_de_fertilidad, color = Country_abbr, group = Country)) +
  geom_line(size = 0.8) +
  geom_point(size = 2) +
  facet_wrap(~Cluster, ncol = 1, strip.position = "left", scales = "free_y") +
  scale_x_continuous(breaks = 2020:2023) +
  theme_minimal() +
  labs(
    title = "Tasa de Fertilidad por Pa√≠s y Cluster (2020‚Äì2023)",
    subtitle = "Agrupado seg√∫n clustering jer√°rquico",
    x = "A√±o",
    y = "Tasa estandarizada",
    color = "Pa√≠s"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 12),
    axis.text.x = element_text(size = 8),
    legend.text = element_text(size = 8),
    legend.title = element_text(face = "bold", size = 9),
    legend.position = "right",
    panel.spacing = unit(1, "lines"),
    strip.text = element_blank(),    # Quitar los n√∫meros de los clusters
    aspect.ratio = 0.3               # Hacer los gr√°ficos m√°s delgados
  )

```

```{r}
# Librer√≠as necesarias
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)  # Para combinar gr√°ficos

### 1. Cluster: 2010‚Äì2014
data_years1 <- data_original[, c("Country", "2010", "2011", "2012", "2013", "2014")]
data_scaled_1 <- scale(data_years1[, -1])
hclust_result <- hclust(dist(data_scaled_1))
clusters_hierarchical <- cutree(hclust_result, k = 3)
data_combined_2010_2014 <- data_years1 %>%
  mutate(Cluster = as.factor(clusters_hierarchical)) %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

data_long_1 <- data_combined_2010_2014 %>%
  pivot_longer(cols = starts_with("20"), names_to = "Year", values_to = "Tasa") %>%
  mutate(Year = as.numeric(Year), Country_abbr = substr(Country, 1, 3))

g1 <- ggplot(data_long_1, aes(x = Year, y = Tasa, color = Country_abbr, group = Country)) +
  geom_line(size = 0.8) +
  geom_point(size = 2) +
  facet_wrap(~Cluster, ncol = 1, strip.position = "left", scales = "free_y") +
  scale_x_continuous(breaks = 2010:2014) +
  theme_minimal() +
  labs(title = "Fertilidad (2010‚Äì2014)", x = "A√±o", y = "Tasa estandarizada", color = "Pa√≠s") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    strip.text = element_blank(),
    legend.position = "none",
    aspect.ratio = 0.3
  )

### 2. Cluster: 2015‚Äì2019
data_years2 <- data_original[, c("Country", "2015", "2016", "2017", "2018", "2019")]
data_scaled_2 <- scale(data_years2[, -1])
hclust_result <- hclust(dist(data_scaled_2))
clusters_hierarchical <- cutree(hclust_result, k = 3)
data_combined_2015_2019 <- data_years2 %>%
  mutate(Cluster = as.factor(clusters_hierarchical)) %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

data_long_2 <- data_combined_2015_2019 %>%
  pivot_longer(cols = starts_with("20"), names_to = "Year", values_to = "Tasa") %>%
  mutate(Year = as.numeric(Year), Country_abbr = substr(Country, 1, 3))

g2 <- ggplot(data_long_2, aes(x = Year, y = Tasa, color = Country_abbr, group = Country)) +
  geom_line(size = 0.8) +
  geom_point(size = 2) +
  facet_wrap(~Cluster, ncol = 1, strip.position = "left", scales = "free_y") +
  scale_x_continuous(breaks = 2015:2019) +
  theme_minimal() +
  labs(title = "Fertilidad (2015‚Äì2019)", x = "A√±o", y = "Tasa estandarizada", color = "Pa√≠s") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    strip.text = element_blank(),
    legend.position = "none",
    aspect.ratio = 0.3
  )

### 3. Cluster: 2020‚Äì2023
data_years3 <- data_original[, c("Country", "2020", "2021", "2022", "2023")]
data_scaled_3 <- scale(data_years3[, -1])
hclust_result <- hclust(dist(data_scaled_3))
clusters_hierarchical <- cutree(hclust_result, k = 3)
data_combined_2020_2023 <- data_years3 %>%
  mutate(Cluster = as.factor(clusters_hierarchical)) %>%
  mutate(
    Cluster = case_when(
      Cluster == "1" ~ "2",
      Cluster == "2" ~ "1",
      TRUE ~ as.character(Cluster)
    ),
    Cluster = as.factor(Cluster)
  )

data_long_3 <- data_combined_2020_2023 %>%
  pivot_longer(cols = starts_with("20"), names_to = "Year", values_to = "Tasa") %>%
  mutate(Year = as.numeric(Year), Country_abbr = substr(Country, 1, 3))

g3 <- ggplot(data_long_3, aes(x = Year, y = Tasa, color = Country_abbr, group = Country)) +
  geom_line(size = 0.8) +
  geom_point(size = 2) +
  facet_wrap(~Cluster, ncol = 1, strip.position = "left", scales = "free_y") +
  scale_x_continuous(breaks = 2020:2023) +
  theme_minimal() +
  labs(title = "Fertilidad (2020‚Äì2023)", x = "A√±o", y = "Tasa estandarizada", color = "Pa√≠s") +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    strip.text = element_blank(),
    legend.position = "right",
    aspect.ratio = 0.3
  )

### Unir los tres gr√°ficos
g1 + g2 + g3 + plot_layout(ncol = 3)

```

```{r}
# Cargar librer√≠as necesarias
library(tidyverse)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(RColorBrewer)
library(glue)

# Leer el archivo de fertilidad
fertility_data <- read.csv("tabla_resumen_fertilidad_transpuesta.csv", check.names = FALSE)

# Transformar a formato largo
fertility_data_long <- fertility_data %>%
  pivot_longer(
    cols = -Country,
    names_to = "Year",
    values_to = "FertilityRate_le18"
  ) %>%
  mutate(Year = as.numeric(Year))

# Obtener el mapa de Sudam√©rica
south_america <- ne_countries(scale = "medium", continent = "South America", returnclass = "sf")

# Funci√≥n para graficar mapas de fertilidad con rangos enteros personalizados
draw_heat_map_fertility <- function() {
  message("Generando mapa de Fertilidad...")

  # Unir mapa con datos
  map_data <- south_america %>%
    left_join(fertility_data_long, by = c("name_long" = "Country")) %>%
    drop_na(Year)

  # Filtrar solo los a√±os deseados
  map_data <- map_data %>% filter(Year %in% c(2010, 2014, 2019, 2023))

  # Crear rangos de n√∫meros enteros
  min_value <- floor(min(map_data$FertilityRate_le18, na.rm = TRUE))
  max_value <- ceiling(max(map_data$FertilityRate_le18, na.rm = TRUE))
  
  # Crear 5 rangos con pasos enteros calculados
  breaks <- seq(min_value, max_value, length.out = 6)  # 5 intervalos = 6 cortes
  breaks <- round(breaks)  # Asegurar que los cortes sean enteros
  breaks <- unique(breaks)  # Eliminar posibles duplicados por redondeo

  # Crear etiquetas personalizadas de los rangos (por ejemplo: "40 - 49")
  labels <- paste0(breaks[-length(breaks)], " - ", breaks[-1] - 1)
  labels[length(labels)] <- paste0(breaks[length(breaks)-1], " - ", breaks[length(breaks)])  # √öltimo rango cerrado

  # Agrupar por rangos personalizados
  map_data <- map_data %>%
    mutate(FertilityRateRange = cut(FertilityRate_le18, breaks = breaks, include.lowest = TRUE, labels = labels))

  # Crear el mapa
  ggplot(data = map_data) +
    geom_sf(aes(fill = FertilityRateRange), color = "black") +
    scale_fill_brewer(palette = "Oranges", na.value = "gray90", name = "Fertility Rate\n(<18 years)") +
    labs(
      title = "Fertility Rates (<18 years) in South America",
      subtitle = ""
    ) +
    facet_wrap(~Year, ncol = 4) +  # 4 mapas en una fila
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      plot.subtitle = element_text(hjust = 0.5, size = 12),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      strip.text = element_text(face = "bold", size = 10),
      legend.position = "right",
      legend.direction = "vertical",
      legend.text = element_text(size = 8),
      legend.title = element_text(face = "bold", size = 9),
      legend.key.height = unit(0.5, "cm"),
      panel.grid = element_blank(),
      panel.spacing = unit(0.5, "lines")
    )
}

# Ejecutar la funci√≥n
```

```{r}
draw_heat_map_fertility()

```

# Education clustering

```{r}
library(tidyr)
library(dplyr)

pisa_scores_ciencias <- pisa_scores %>%
  filter(Subject == "Ciencias") %>%
  rename(PisaCiencias = Value)
```

Merging datasets

```{r}
merged_data <- births_data_grouped %>%
  select(Country, `ISO3 Alpha-code`, Year, `TotalWomen_le18`, `Births_le18`,`FertilityRate_le18` )
```

```{r}
education_completion_rates <- read_excel("Data/education_completion_rate.xlsx")
education_completion_rates <- education_completion_rates %>%
  filter(indicatorId == "CR.MOD.3") %>%
  select(geoUnit, year, value) %>%
  rename(education_completion_rate = value)

merged_data <- merged_data %>%
  left_join(education_completion_rates,
            by = c("ISO3 Alpha-code" = "geoUnit", "Year" = "year"))
```

```{r}

# Funci√≥n para graficar solo los a√±os seleccionados con leyenda por rangos en fila
draw_selected_education_maps_horizontal <- function() {
  message("Generando mapa de educaci√≥n en fila horizontal con leyenda por rangos...")

  # A√±os espec√≠ficos que quieres mostrar
  selected_years <- c(2010, 2014, 2019, 2023)

  # Preparar los datos
  data <- merged_data %>%
    dplyr::select(all_of(c("ISO3 Alpha-code", "Year", "education_completion_rate"))) %>%
    drop_na(education_completion_rate) %>%
    filter(Year %in% selected_years)

  # Crear categor√≠as de rangos
  breaks <- c(30, 50, 70, 85, 100)  # Puedes ajustar estos cortes
  labels <- c("30‚Äì50", "50‚Äì70", "70‚Äì85", "85‚Äì100")

  # Crear columna con los rangos
  data <- data %>%
    mutate(education_range = cut(education_completion_rate, breaks = breaks, labels = labels, include.lowest = TRUE))

  # Unir con el mapa
  map_data <- south_america %>%
    left_join(data, by = c("iso_a3" = "ISO3 Alpha-code")) %>%
    drop_na(Year)

  # Crear el gr√°fico
  p <- ggplot(data = map_data) +
    geom_sf(aes(fill = education_range), color = "black") +
    scale_fill_brewer(palette = "Purples", name = "Education\nCompletion Rate (%)", na.value = "gray90") +
    labs(
      title = "Education Completion Rates in South America",
      
    ) +
    facet_wrap(~Year, ncol = 4) +  # üëâ En fila (4 columnas)
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
      plot.subtitle = element_text(hjust = 0.5, size = 12),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      axis.title = element_blank(),
      strip.text = element_text(face = "bold", size = 12),
      legend.position = "right",
      legend.direction = "vertical",
      legend.text = element_text(size = 10),
      legend.title = element_text(face = "bold", size = 11),
      legend.key.height = unit(0.5, "cm"),
      panel.grid = element_blank(),
      panel.spacing = unit(1.5, "lines")  # M√°s espacio entre mapas
    )

  # Mostrar en consola
  print(p)

  # Exportar el gr√°fico (m√°s ancho para que los mapas no se aplasten)
  ggsave("education_map_selected_years_horizontal.png", plot = p, width = 20, height = 7, dpi = 300)
}

# Ejecutar la funci√≥n
draw_selected_education_maps_horizontal()


```

```{r}
hdi_countries <- read_excel("Data/HDI_countries.xlsx")

life_expectancy <- read_csv("Data/life-expectancy.csv")

life_expectancy <- life_expectancy %>%
  filter(Code %in% latam_iso3) %>%
  rename(life_expectancy = `Period life expectancy at birth - Sex: total - Age: 0`) %>%
  dplyr::select(Code, Year, life_expectancy)

merged_data <- merged_data %>%
  left_join(life_expectancy,
            by = c("ISO3 Alpha-code" = "Code", "Year" = "Year"))
```

```{r}
m_all <- lm(merged_data$FertilityRate_le18 ~ merged_data$education_completion_rate)
summary(m_all)
```

```{r}
merged_data_peru <- merged_data %>%
  filter(Country == "Peru")
m_peru <- lm(merged_data_peru$FertilityRate_le18 ~ merged_data_peru$education_completion_rate)
summary(m_peru)
```

```{r}
gdp_countries <- read_excel("Data/gdp_per_capita_ppp.xlsx")

gdp_countries <- gdp_countries %>%
  filter(`Code` %in% latam_iso3) %>%
  rename(gdp_per_capita = `GDP per capita, PPP (constant 2021 international $)`) %>%
  select(Code, Year, gdp_per_capita) %>%
  mutate(Year = as.double(Year))

# XXX: No data for Venezuela's GDP
merged_data <- merged_data %>%
  inner_join(gdp_countries,
            by = c("ISO3 Alpha-code" = "Code", "Year" = "Year"))
```

```{r}
library(dplyr)
library(broom)

# Run regression for each country
country_models <- merged_data %>%
  group_by(Country) %>%
  nest() %>%  # Creates nested data frames
  mutate(
    # Fit model to each country's data
    model = map(data, ~lm(FertilityRate_le18 ~ education_completion_rate, data = .x)),
    # Extract results
    tidy_results = map(model, tidy),
    glance_results = map(model, glance)
  )

# View coefficients for all countries
country_coefficients <- country_models %>%
  unnest(tidy_results) %>%
  select(Country, term, estimate, std.error, p.value)

print(country_coefficients)

# View model fit statistics
country_fit <- country_models %>%
  unnest(glance_results) %>%
  select(Country, r.squared, adj.r.squared, p.value, nobs)

print(country_fit)
```

```{r}
# Cargar librer√≠as necesarias
library(tidyverse)
library(lmtest)
library(ggplot2)
library(gridExtra)

# 1. Ajuste del modelo lineal simple
m_all <- lm(FertilityRate_le18 ~ education_completion_rate, data = merged_data)
summary(m_all)

# 2. Prueba RESET de especificaci√≥n (linealidad)
resettest(m_all)

# 3. Gr√°ficos de residuos para evaluar linealidad

# Residuos vs. PISA (Value)
Linealidad1 <- ggplot(data = merged_data, aes(education_completion_rate, resid(m_all))) +
  geom_point() +
  geom_smooth(color = "firebrick") +
  geom_hline(yintercept = 0) +
  theme_bw() +
  labs(title = "Residuos vs. PISA Score (Value)", y = "Residuos")

# Residuos vs. Year (ajustando el eje a a√±os enteros)
Linealidad2 <- ggplot(data = merged_data, aes(Year, resid(m_all))) +
  geom_point() +
  geom_smooth(color = "firebrick") +
  geom_hline(yintercept = 0) +
  scale_x_continuous(breaks = seq(min(merged_data$Year), max(merged_data$Year), 1)) +
  theme_bw() +
  labs(title = "Residuos vs. Year", y = "Residuos", x = "A√±o")

# Mostrar ambos gr√°ficos juntos
grid.arrange(Linealidad1, Linealidad2)

# 4. Si la prueba RESET sugiere no linealidad, ajustar un modelo polinomial
m_all2 <- lm(FertilityRate_le18 ~ education_completion_rate + I(education_completion_rate^2), data = merged_data)
summary(m_all2)

# Volver a graficar residuos con el modelo cuadr√°tico
Linealidad1_poly <- ggplot(data = merged_data, aes(education_completion_rate, resid(m_all2))) +
  geom_point() +
  geom_smooth(color = "blue") +
  geom_hline(yintercept = 0) +
  theme_bw() +
  labs(title = "Residuos vs. PISA Score (Modelo Cuadr√°tico)", y = "Residuos")

grid.arrange(Linealidad1_poly)

# 5. (Opcional) Ajuste con GAM si la relaci√≥n sigue siendo compleja
library(mgcv)
m_gam <- gam(FertilityRate_le18 ~ s(education_completion_rate) + s(Year), data = merged_data)
summary(m_gam)

# Gr√°fico de residuos para el GAM
Linealidad1_gam <- ggplot(data = merged_data, aes(education_completion_rate, resid(m_gam))) +
  geom_point() +
  geom_smooth(color = "darkgreen") +
  geom_hline(yintercept = 0) +
  theme_bw() +
  labs(title = "Residuos vs. PISA Score (Modelo GAM)", y = "Residuos")

grid.arrange(Linealidad1_gam)


```

```{r}
## Normalidad de los residuos

# Realizamos la prueba de Shapiro-Wilk
shapiro_test <- shapiro.test(resid(m_all))
shapiro_test

# Interpretaci√≥n:
# Si el p-valor es mayor a 0.05, no se rechaza la hip√≥tesis de normalidad.

# Realizamos el gr√°fico Q-Q Plot
library(car)
qqPlot(resid(m_all), main = "Q-Q Plot de residuos")

# Conclusi√≥n esperada:
# Si los puntos siguen aproximadamente la l√≠nea diagonal, no se rechaza la normalidad.

```

```{r}
## Homocedasticidad de los residuos

# Prueba de Breusch-Pagan (H0: Homocedasticidad, Ha: Heterocedasticidad)
library(lmtest)
lmtest::bptest(m_all)

# Interpretaci√≥n:
# Si el p-valor es menor a 0.05, se rechaza la hip√≥tesis de homocedasticidad (es decir, hay heterocedasticidad).

# Gr√°fico de residuos vs. valores ajustados
ggplot(data = merged_data, aes(m_all$fitted.values, resid(m_all))) +
  geom_point() +
  geom_smooth(color = "firebrick", se = FALSE) +
  geom_hline(yintercept = 0) +
  theme_bw() +
  labs(x = "Valores Ajustados", y = "Residuos", title = "Residuos vs. Valores Ajustados")

```

```{r}
### Verificaci√≥n de los supuestos de Linealidad, Independencia, Normalidad y Homocedasticidad a la vez
## Verificaci√≥n conjunta de los supuestos con ggfortify

# Cargar la librer√≠a ggfortify
library(ggfortify)

# Graficar los 4 gr√°ficos diagn√≥sticos cl√°sicos
autoplot(m_all)
```

```{r}

# Primero, aseg√∫rate de que los nombres de columnas coincidan
# Por ejemplo, si en education_completion_rate se llama "pais", renombramos:
education_completion_rates <- education_completion_rates %>%
  rename(Country = geoUnit, Year = year)
```

```{r}
# Luego hacemos el join
merged_data <- merged_data %>%
  left_join(education_completion_rates, by = c("ISO3 Alpha-code" = "Country", "Year" = "Year" ))
```

```{r}
# Eliminar filas con valores NA en variables relevantes
data_poisson <- merged_data %>%
  select(Country, Year, Births_le18, education_completion_rate.x, TotalWomen_le18, life_expectancy, gdp_per_capita) %>%
  na.omit()

```

```{r}
# Cargar librer√≠a si no est√° cargada
library(stats)

# Modelo de Poisson
modelo_poisson <- glm(Births_le18 ~ education_completion_rate.x + TotalWomen_le18 + life_expectancy + gdp_per_capita,
                      data = data_poisson,
                      family = poisson(link = "log"))

# Ver resultados
summary(modelo_poisson)

```

```{r}
# Calcular ratio de sobredispersi√≥n
dispersion <- sum(residuals(modelo_poisson, type = "pearson")^2) / modelo_poisson$df.residual
dispersion

```

```{r}
modelo_quasi <- glm(Births_le18 ~ education_completion_rate.x + TotalWomen_le18 + life_expectancy + gdp_per_capita,
                    data = data_poisson,
                    family = quasipoisson(link = "log"))

summary(modelo_quasi)
```

```{r}
library(MASS)

modelo_nb <- glm.nb(Births_le18 ~ education_completion_rate.x + TotalWomen_le18 + life_expectancy + gdp_per_capita,
                    data = data_poisson)

summary(modelo_nb)

```

```{r}
poisson_model <- glm(
  Births_le18 ~  education_completion_rate.x + life_expectancy + gdp_per_capita + Year,
  data = merged_data,
  family = poisson(link = "log"),
  offset = log(TotalWomen_le18)
)
summary(poisson_model)

```

```{r}
dispersion <- sum(residuals(poisson_model, type = "pearson")^2) / poisson_model$df.residual
dispersion
```

```{r}
# Instalar si no est√° instalado
# install.packages("MASS")
# install.packages("pscl")

library(MASS)
library(pscl)

# Modelo Binomial Negativa para predecir Births_le18
Modelo_BN <- glm.nb(
  Births_le18 ~ education_completion_rate.x + life_expectancy + gdp_per_capita + Year + offset(log(TotalWomen_le18)),
  data = merged_data
)

# Resumen del modelo
summary(Modelo_BN)

# AIC: puedes comparar con otros modelos si ya los has definido
# AIC(Modelo_Poisson, Modelo_QP, Modelo_BN) # Solo si has creado los otros modelos

# Coeficientes exponenciados con intervalos de confianza
exp(cbind(coef(Modelo_BN), confint(Modelo_BN)))

```

```{r}
# Aseg√∫rate de tener las librer√≠as instaladas
install.packages("ggplot2")
install.packages("dplyr") # Para manipulaci√≥n de datos, aunque no estrictamente necesario aqu√≠, es √∫til.

# Cargar las librer√≠as
library(ggplot2)
library(dplyr)
library(MASS) # Para glm.nb

# Suponiendo que 'merged_data' ya est√° cargado y el modelo 'Modelo_BN' ya fue ajustado.
# Si no lo tienes, puedes correr el c√≥digo de tu modelo Binomial Negativa:
# Modelo_BN <- glm.nb(
#   Births_le18 ~ education_completion_rate.x + hdi + gdp_per_capita + Year + offset(log(TotalWomen_le18)),
#   data = merged_data
# )

# 1. Extraer los coeficientes y los intervalos de confianza del modelo
# Exponenciar los coeficientes y los intervalos de confianza para obtener las IRR
irr_data <- as.data.frame(exp(cbind(IRR = coef(Modelo_BN), confint(Modelo_BN))))

# Renombrar las columnas para mayor claridad
colnames(irr_data) <- c("IRR", "Lower_CI", "Upper_CI")

# 2. Preparar los datos para ggplot2
# Convertir los nombres de las filas (variables) en una columna
irr_data$Variable <- rownames(irr_data)

# Reordenar las variables para una mejor visualizaci√≥n (opcional)
irr_data$Variable <- factor(irr_data$Variable,
                             levels = c("Year", "gdp_per_capita", "life_expectancy", "education_completion_rate.x", "(Intercept)"))

# Excluir el intercepto para la visualizaci√≥n, ya que su IRR suele ser dif√≠cil de interpretar
# y a menudo de una escala muy diferente
irr_data_plot <- irr_data %>%
  filter(Variable != "(Intercept)")

# 3. Crear el gr√°fico de barras con los intervalos de confianza

ggplot(irr_data_plot, aes(x = Variable, y = IRR)) +
  geom_bar(stat = "identity", fill = "steelblue", width = 0.7) + # Barras para la IRR
  geom_errorbar(aes(ymin = Lower_CI, ymax = Upper_CI), width = 0.2, color = "black") + # Barras de error para los IC
  geom_hline(yintercept = 1, linetype = "dashed", color = "red", size = 0.8) + # L√≠nea de referencia en 1 (no efecto)
  labs(
    title = "Razones de Tasas de Incidencia (IRR) con Intervalos de Confianza (95%)",
    x = "Variable Predictora",
    y = "Raz√≥n de Tasa de Incidencia (IRR)"
  ) +
  scale_y_continuous(trans = 'log2', breaks = c(0.1, 0.5, 1, 2, 5, 10, 50, 100, 200)) + # Escala logar√≠tmica para manejar rangos amplios
  coord_flip() + # Voltear las coordenadas para que las barras sean horizontales
  theme_minimal() + # Tema minimalista para una apariencia limpia
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )
```

```{r}
library(ggplot2)
ggplot(merged_data, aes(x = life_expectancy, y = Births_le18 / TotalWomen_le18)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "glm.nb", formula = y ~ x, se = FALSE, color = "blue") + # O method = "lm" si quieres una l√≠nea recta
  labs(title = "Tasa de Fertilidad Adolescente vs. Life Expectancy",
       x = "Life Expectancy",
       y = "Tasa de Nacimientos (<18)") +
  theme_minimal()
```

```{r}
library(car)
vif(Modelo_BN)
```

```{r}
AIC(poisson_model, Modelo_BN)

```

```{r}
plot(fitted(Modelo_BN), residuals(Modelo_BN, type = "deviance"),
     xlab = "Valores ajustados", ylab = "Residuos de devianza",
     main = "Residuos vs Ajustados")
abline(h = 0, col = "red")

```

```{r}
hist(residuals(Modelo_BN, type = "pearson"), breaks = 20,
     main = "Histograma de residuos", xlab = "Residuos de Pearson")

```

```{r}
qqnorm(residuals(Modelo_BN, type = "pearson"))
qqline(residuals(Modelo_BN, type = "pearson"), col = "red")

```

```{r}
library(pscl)
pR2(Modelo_BN)

```

```{r}
plot(merged_data$Births_le18, fitted(Modelo_BN),
     xlab = "Nacimientos observados", ylab = "Nacimientos predichos",
     main = "Observados vs Predichos")
abline(0, 1, col = "blue")

```

```{r}
# Agregar las predicciones al dataframe original
merged_data$pred_BN <- predict(Modelo_BN, type = "response")

```

```{r}
# Extraer coeficientes como data frame
coef_df <- as.data.frame(summary(Modelo_BN)$coefficients)

# Agregar nombres de las variables como columna
coef_df$Variable <- rownames(coef_df)

# Reordenar columnas
coef_df <- coef_df[, c("Variable", "Estimate", "Std. Error", "z value", "Pr(>|z|)")]


```

```{r}
library(pscl)

r2 <- pR2(Modelo_BN)["McFadden"]
aic <- AIC(Modelo_BN)

# Guardar como data.frame
metricas_df <- data.frame(
  Modelo = "Binomial Negativa",
  McFadden_R2 = r2,
  AIC = aic
)
```

# Comparando Poisson y Binomial Negativa

```{r}
res_dev <- deviance(poisson_model)
df <- df.residual(poisson_model)
dispersion_ratio <- res_dev / df
dispersion_ratio
```

```{r}
library(lmtest)
lrtest(poisson_model, Modelo_BN)

```

```{r}
AIC(poisson_model, Modelo_BN)

```

```{r}
library(MASS)

Modelo_BN_bivariado <- glm.nb(
  Births_le18 ~ education_completion_rate.x + offset(log(TotalWomen_le18)),
  data = merged_data
)
```

```{r}
summary(Modelo_BN_bivariado)
```

```{r}
exp(coef(Modelo_BN_bivariado))
```

```{r}
exp(confint(Modelo_BN_bivariado))
```

```{r}
summary(Modelo_BN_bivariado)
summary(Modelo_BN)

```

```{r}
AIC(Modelo_BN_bivariado, Modelo_BN)
library(lmtest)
lrtest(Modelo_BN_bivariado, Modelo_BN)
```
